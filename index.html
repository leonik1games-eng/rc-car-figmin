<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SS Play RC - Power Edition</title>
    <meta name="figmin">
    <style>
        body { background: transparent; font-family: sans-serif; text-align: center; overflow: hidden; margin: 0; pointer-events: none; }
        .hud { position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.85); color: #00ff00; padding: 15px; border-radius: 12px; border: 1px solid #444; max-width: 250px; text-align: left; pointer-events: auto; }
        h1 { margin: 0 0 5px; font-size: 16px; color: white; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .status { font-weight: bold; color: #fbbf24; margin-top: 5px; font-size: 14px; }
    </style>
</head>
<body>

    <div class="hud">
        <h1>SS PLAY RC POWER</h1>
        <div id="status" class="status">Aguardando Raio...</div>
        <div style="margin-top:10px; font-size:11px; color:#ccc;">
            • R2: Acelerar<br>
            • Analógico: Direção<br>
            • Clique Analógico: Reset
        </div>
    </div>

    <script>
        // --- AJUSTES DE PERFORMANCE ---
        const FORCA_MOTOR = 800.0;   // Aumentado para vencer o peso
        const VEL_CURVA = 4.5;       // Curva mais ágil
        const PESO_GRAVIDADE = 3.5;  // Mais gravidade para não pular
        const CORRIGIR_LADO = false; 
        // -------------------------------

        var car = null;
        var statusDiv = document.getElementById("status");

        function rotateVector(q, v) {
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            var vx = v.x, vy = v.y, vz = v.z;
            var ix = qw * vx + qy * vz - qz * vy;
            var iy = qw * vy + qz * vx - qx * vz;
            var iz = qw * vz + qx * vy - qy * vx;
            var iw = -qx * vx - qy * vy - qz * vz;
            return {
                x: ix * qw + iw * -qx + iy * -qz - iz * -qy,
                y: iy * qw + iw * -qy + iz * -qx - ix * -qz,
                z: iz * qw + iw * -qz + ix * -qy - iy * -qx
            };
        }

        document.addEventListener("FigminReady", function() {
            car = figmin.findObjectByName("meu_carro");
            if (car) {
                statusDiv.innerText = "PRONTO! ⚡";
                setupCar();
            }
        });

        function setupCar() {
            car.addComponent(figmin.ComponentType.PHYSICS, {
                mass: 3.0,            
                drag: 1.2,            
                angularDrag: 4.0,     
                gravityStrength: PESO_GRAVIDADE,
                collisionDetectionMode: figmin.physics.CollisionDetectionMode.CONTINUOUS_DYNAMIC,
                kinematic: false 
            });

            car.addComponent(figmin.ComponentType.PHYSICS_MATERIAL, {
                bounciness: 0.05,     
                staticFriction: 0.5,  
                dynamicFriction: 0.3  
            });

            figmin.enableInputConnect("Pilotar", [
                figmin.InputCode.SELECT_RIGHT,
                figmin.InputCode.AXIS_Y_RIGHT,
                figmin.InputCode.AXIS_X_RIGHT,
                figmin.InputCode.THUMB_RIGHT
            ], onConnect, car);

            figmin.setUpdateFunction(update);
        }

        function onConnect(connected) {
            statusDiv.innerText = connected ? "PILOTANDO!" : "Conecte o Raio";
            statusDiv.style.color = connected ? "#00ff00" : "#fbbf24";
            if (connected && car.physics) {
                car.physics.kinematic = false;
                car.physics.wakeUp();
            }
        }

        function update(dt) {
            if (!car || !car.physics) return;

            var throttle = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var stickY = figmin.getInput(figmin.InputCode.AXIS_Y_RIGHT);
            var resetBtn = figmin.getInput(figmin.InputCode.THUMB_RIGHT);

            var isReversing = false;
            if (stickY < -0.2) {
                throttle = Math.abs(stickY);
                isReversing = true;
            }

            var localFwd = CORRIGIR_LADO ? {x:1, y:0, z:0} : {x:0, y:0, z:1};
            var worldFwd = rotateVector(car.transform.rotationq, localFwd);
            var direction = isReversing ? -1 : 1;

            if (throttle > 0.05) {
                // Força aplicada frame a frame
                var forceMag = throttle * FORCA_MOTOR * direction * dt * 60;
                car.physics.applyForce({
                    x: worldFwd.x * forceMag,
                    y: worldFwd.y * forceMag,
                    z: worldFwd.z * forceMag
                });
            }

            if (Math.abs(steer) > 0.1) {
                var currentAng = car.physics.angularVelocity;
                car.physics.setAngularVelocity({
                    x: currentAng.x * 0.5, 
                    y: steer * VEL_CURVA,
                    z: currentAng.z * 0.5  
                });
            }

            // Manter estável
            if (car.transform.up.y < 0.7) {
                var rot = car.transform.rotation;
                car.transform.rotation = { x: 0, y: rot.y, z: 0 };
            }

            if (resetBtn) doReset();
        }

        function doReset() {
            car.physics.setLinearVelocity({x:0, y:0, z:0});
            car.physics.setAngularVelocity({x:0, y:0, z:0});
            var cam = figmin.getCamera();
            var fwd = cam.transform.forward;
            var pos = cam.transform.position;
            car.transform.position = {
                x: pos.x + fwd.x * 2.0,
                y: pos.y + 0.5, // Nasce um pouco no ar pra não travar no chão
                z: pos.z + fwd.z * 2.0
            };
            car.transform.rotation = { x:0, y: cam.transform.rotation.y, z:0 };
        }
    </script>
</body>
</html>
