<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SS Play RC - Native</title>
    <meta name="figmin">
    <style>
        body {
            background: transparent;
            font-family: sans-serif;
            text-align: center;
            overflow: hidden;
            margin: 0;
            pointer-events: none;
        }
        .hud {
            position: fixed; top: 20px; left: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #3b82f6;
            color: #fff;
            padding: 20px;
            border-radius: 15px;
            text-align: left;
            pointer-events: auto;
            width: 300px;
        }
        .stat { color: #00ff00; font-weight: bold; font-size: 16px; }
        .controls { margin-top: 15px; font-size: 14px; color: #ccc; line-height: 1.6; }
    </style>
</head>
<body>

    <div class="hud">
        <h3 style="margin:0; color:#3b82f6;">SS PLAY RC <span style="font-size:12px; color:#fff;">v18.0</span></h3>
        <div id="status" class="stat">Aguardando Conex√£o...</div>
        <hr style="border-color:#333">
        <div class="controls">
            üëâ <b>R2 (Gatilho Dir):</b> Acelerar<br>
            üëà <b>L2 (Gatilho Esq):</b> R√© / Freio<br>
            üïπÔ∏è <b>Anal√≥gico:</b> Dire√ß√£o<br>
            üõë <b>Bot√£o A:</b> Resetar
        </div>
    </div>

    <script>
        // --- AJUSTES DE F√çSICA ---
        const FORCA_MOTOR = 80.0;
        const VEL_CURVA = 3.5;
        const PESO = 3.0;
        
        // Se o carro andar de lado, mude para true
        const MODELO_DE_LADO = false; 
        // --------------------------

        var car = null;
        var statusDiv = document.getElementById("status");

        // --- FUN√á√ïES MATEM√ÅTICAS (Copiadas do script do Avi√£o) ---
        // Elas garantem que a for√ßa seja aplicada LOCALMENTE
        function quaternionMultiply(q1, q2) {
            return {
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
            };
        }
        function quaternionConjugate(q) { return { w: q.w, x: -q.x, y: -q.y, z: -q.z }; }
        function quaternionRotateVector(q, v) {
            var qv = { w: 0, x: v.x, y: v.y, z: v.z };
            var qConj = quaternionConjugate(q);
            var q1 = quaternionMultiply(q, qv);
            var q2 = quaternionMultiply(q1, qConj);
            return { x: q2.x, y: q2.y, z: q2.z };
        }

        // --- INICIALIZA√á√ÉO (Igual ao do Avi√£o) ---
        document.addEventListener("FigminReady", init);

        function init() {
            // Busca direta, uma √∫nica vez
            car = figmin.findObjectByName("meu_carro");

            if (car) {
                statusDiv.innerText = "PRONTO! CLIQUE NO RAIO ‚ö°";
                setupCar(car);
            } else {
                statusDiv.innerText = "ERRO: 'meu_carro' n√£o encontrado.";
                statusDiv.style.color = "red";
            }
        }

        function setupCar(obj) {
            // Configura f√≠sica
            obj.addComponent(figmin.ComponentType.PHYSICS, {
                mass: PESO,
                drag: 2.0,            
                angularDrag: 4.0,     
                gravityStrength: 1.0, 
                kinematic: false      
            });

            // Conex√£o de input
            figmin.enableInputConnect("Controle RC", [
                figmin.InputCode.SELECT_RIGHT, // R2
                figmin.InputCode.SELECT_LEFT,  // L2
                figmin.InputCode.AXIS_X_RIGHT, // Dire√ß√£o
                figmin.InputCode.BUTTON_1      // Reset
            ], onInputConnectionChanged, obj);

            // Loop de atualiza√ß√£o
            figmin.setUpdateFunction(update);
        }

        function onInputConnectionChanged(connected, playerId) {
            statusDiv.innerText = connected ? "PILOTANDO!" : "Desconectado";
            statusDiv.style.color = connected ? "#00ff00" : "yellow";
            if (connected && car && car.physics) {
                car.physics.wakeUp();
            }
        }

        function update(dt) {
            if (!car || !car.physics) return;

            // Inputs
            var throttleFwd = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var throttleRev = figmin.getInput(figmin.InputCode.SELECT_LEFT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var resetBtn = figmin.getInput(figmin.InputCode.BUTTON_1);

            // Calcula For√ßa (Frente - R√©)
            var inputForce = 0;
            if (throttleFwd > 0.05) inputForce = throttleFwd;
            if (throttleRev > 0.05) inputForce = -throttleRev;

            // --- F√çSICA CORRIGIDA COM QUATERNIONS ---
            
            // 1. Define o vetor de empuxo LOCAL (Relativo ao chassi do carro)
            var thrustLocal = { x: 0, y: 0, z: 0 };
            
            if (MODELO_DE_LADO) {
                thrustLocal.x = inputForce * FORCA_MOTOR; // Se o modelo for torto (X √© frente)
            } else {
                thrustLocal.z = inputForce * FORCA_MOTOR; // Padr√£o (Z √© frente)
            }

            // 2. Converte para GLOBAL usando a rota√ß√£o do carro
            // (Is
