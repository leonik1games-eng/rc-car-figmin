<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SS Play RC - Pro Physics</title>
    <meta name="figmin">
    <style>
        body { background: transparent; font-family: sans-serif; text-align: center; overflow: hidden; margin: 0; pointer-events: none; }
        .hud { position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.85); color: #00ff00; padding: 15px; border-radius: 12px; border: 1px solid #444; max-width: 250px; text-align: left; pointer-events: auto; }
        h1 { margin: 0 0 5px; font-size: 16px; color: white; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .status { font-weight: bold; color: #fbbf24; margin-top: 5px; font-size: 14px; }
    </style>
</head>
<body>

    <div class="hud">
        <h1>SS PLAY RC PRO</h1>
        <div id="status" class="status">Procurando 'meu_carro'...</div>
        <div style="margin-top:10px; font-size:11px; color:#ccc;">
            • R2: Acelerar<br>
            • Analógico: Direção<br>
            • Clique Analógico: Reset
        </div>
    </div>

    <script>
        // --- AJUSTES DE ESTABILIDADE ---
        const FORCA_MOTOR = 80.0;    // Valor menor para evitar o efeito "foguete"
        const VEL_CURVA = 3.5;       // Curva mais cadenciada
        const PESO_GRAVIDADE = 2.5;  // Gravidade realista
        const CORRIGIR_LADO = false; 
        // -------------------------------

        var car = null;
        var statusDiv = document.getElementById("status");

        function rotateVector(q, v) {
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            var vx = v.x, vy = v.y, vz = v.z;
            var ix = qw * vx + qy * vz - qz * vy;
            var iy = qw * vy + qz * vx - qx * vz;
            var iz = qw * vz + qx * vy - qy * vx;
            var iw = -qx * vx - qy * vy - qz * vz;
            return {
                x: ix * qw + iw * -qx + iy * -qz - iz * -qy,
                y: iy * qw + iw * -qy + iz * -qx - ix * -qz,
                z: iz * qw + iw * -qz + ix * -qy - iy * -qx
            };
        }

        document.addEventListener("FigminReady", function() {
            if (!figmin.isSpatialApp()) { figmin.requireSpatialApp(); return; }
            car = figmin.findObjectByName("meu_carro");
            if (car) {
                statusDiv.innerText = "CARRO PRONTO! ⚡";
                statusDiv.style.color = "#00ff00";
                setupCar();
            }
        });

        function setupCar() {
            // FÍSICA ESTÁVEL
            car.addComponent(figmin.ComponentType.PHYSICS, {
                mass: 5.0,            // Mais pesado para não pular
                drag: 1.5,            // Freio motor (não desliza como gelo)
                angularDrag: 4.0,     // Estabiliza o giro rapidamente
                gravityStrength: PESO_GRAVIDADE,
                collisionDetectionMode: figmin.physics.CollisionDetectionMode.CONTINUOUS_DYNAMIC,
                kinematic: false 
            });

            // MATERIAL DE ALTO ATRITO (BORRACHA)
            car.addComponent(figmin.ComponentType.PHYSICS_MATERIAL, {
                bounciness: 0.0,      // Não pula ao bater
                staticFriction: 0.8,  // Agarra no chão parado
                dynamicFriction: 0.6  // Agarra no chão correndo
            });

            figmin.enableInputConnect("Pilotar", [
                figmin.InputCode.SELECT_RIGHT,
                figmin.InputCode.AXIS_Y_RIGHT,
                figmin.InputCode.AXIS_X_RIGHT,
                figmin.InputCode.THUMB_RIGHT
            ], onConnect, car);

            figmin.setUpdateFunction(update);
        }

        function onConnect(connected) {
            statusDiv.innerText = connected ? "CONECTADO!" : "Aguardando Raio...";
            statusDiv.style.color = connected ? "#00ff00" : "#fbbf24";
            if (connected && car.physics) {
                car.physics.kinematic = false;
                car.physics.wakeUp();
            }
        }

        function update(dt) {
            if (!car || !car.physics) return;

            var throttle = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var stickY = figmin.getInput(figmin.InputCode.AXIS_Y_RIGHT);
            var resetBtn = figmin.getInput(figmin.InputCode.THUMB_RIGHT);

            var isReversing = false;
            if (stickY < -0.2) {
                throttle = Math.abs(stickY);
                isReversing = true;
            }

            // Direção Local
            var localFwd = CORRIGIR_LADO ? {x:1, y:0, z:0} : {x:0, y:0, z:1};
            var worldFwd = rotateVector(car.transform.rotationq, localFwd);
            var direction = isReversing ? -1 : 1;

            // 1. ACELERAÇÃO SUAVE
            if (throttle > 0.05) {
                // Multiplicamos pela massa para garantir que ele se mova com 5kg
                var forceMag = throttle * FORCA_MOTOR * direction * car.physics.mass;
                car.physics.applyForce({
                    x: worldFwd.x * forceMag,
                    y: worldFwd.y * forceMag,
                    z: worldFwd.z * forceMag
                });
            }

            // 2. CURVA CONTROLADA
            if (Math.abs(steer) > 0.1) {
                var currentAng = car.physics.angularVelocity;
                car.physics.setAngularVelocity({
                    x: currentAng.x * 0.5, // Mata inclinação frontal
                    y: steer * VEL_CURVA,
                    z: currentAng.z * 0.5  // Mata capotamento lateral
                });
            }

            // 3. ESTABILIZADOR (Mantém as 4 rodas no chão)
            if (car.transform.up.y < 0.8) {
                // Força o carro a ficar em pé se ele começar a inclinar
                var rot = car.transform.rotation;
                car.transform.rotation = { x: 0, y: rot.y, z: 0 };
            }

            if (resetBtn) doReset();
        }

        function doReset() {
            car.physics.setLinearVelocity({x:0, y:0, z:0});
            car.physics.setAngularVelocity({x:0, y:0, z:0});
            var cam = figmin.getCamera();
            var fwd = cam.transform.forward;
            var pos = cam.transform.position;
            car.transform.position = {
                x: pos.x + fwd.x * 2.0,
                y: pos.y, 
                z: pos.z + fwd.z * 2.0
            };
            car.transform.rotation = { x:0, y: cam.transform.rotation.y, z:0 };
        }
    </script>
</body>
</html>
