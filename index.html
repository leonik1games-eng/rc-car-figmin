<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SS Play RC - Calibração de Eixo</title>
    <meta name="figmin">
    <style>
        body { background: transparent; font-family: sans-serif; text-align: center; margin: 0; pointer-events: none; }
        .hud { 
            position: fixed; top: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); color: #00ff00; 
            padding: 15px; border-radius: 12px; border: 1px solid #444; 
            max-width: 300px; text-align: left; pointer-events: auto; 
        }
        b { color: yellow; }
    </style>
</head>
<body>

    <div class="hud">
        <h1>CALIBRAÇÃO DE EIXO</h1>
        <div id="status">Conecte o Raio...</div>
        <hr>
        <div style="font-size:12px; color:#ccc;">
            Ângulo Atual: <b id="valAngulo">0</b>°<br>
            <p>Se o carro não andar para frente, me avise o ângulo que você testou.</p>
        </div>
    </div>

    <script>
        // --- CALIBRAÇÃO (MUDE AQUI) ---
        // Tente valores como: 90, 180, 270 ou 135 (para diagonais)
        const AJUSTE_ANGULO = 0; 
        
        const FORCA_MOTOR = 800.0;
        const VEL_CURVA = 4.0;
        // ------------------------------

        var car = null;

        function rotateVector(q, v) {
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            var vx = v.x, vy = v.y, vz = v.z;
            var ix = qw * vx + qy * vz - qz * vy;
            var iy = qw * vy + qz * vx - qx * vz;
            var iz = qw * vz + qx * vy - qy * vx;
            var iw = -qx * vx - qy * vy - qz * vz;
            return {
                x: ix * qw + iw * -qx + iy * -qz - iz * -qy,
                y: iy * qw + iw * -qy + iz * -qx - ix * -qz,
                z: iz * qw + iw * -qz + ix * -qy - iy * -qx
            };
        }

        document.getElementById("valAngulo").innerText = AJUSTE_ANGULO;

        document.addEventListener("FigminReady", function() {
            car = figmin.findObjectByName("meu_carro");
            if (car) {
                setupCar();
            }
        });

        function setupCar() {
            car.addComponent(figmin.ComponentType.PHYSICS, {
                mass: 3.0, drag: 1.0, angularDrag: 3.0,
                gravityStrength: 3.0, kinematic: false 
            });

            figmin.enableInputConnect("Pilotar", [
                figmin.InputCode.SELECT_RIGHT,
                figmin.InputCode.AXIS_Y_RIGHT,
                figmin.InputCode.AXIS_X_RIGHT,
                figmin.InputCode.THUMB_RIGHT
            ], (c) => { 
                document.getElementById("status").innerText = c ? "CONECTADO!" : "Aguardando Raio...";
            }, car);

            figmin.setUpdateFunction(update);
        }

        function update(dt) {
            if (!car || !car.physics) return;

            var throttle = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var stickY = figmin.getInput(figmin.InputCode.AXIS_Y_RIGHT);
            
            if (stickY < -0.2) throttle = -Math.abs(stickY);

            // --- CÁLCULO DO EIXO CORRETO ---
            var rad = AJUSTE_ANGULO * (Math.PI / 180);
            
            // Criamos um vetor de frente baseado no ângulo de calibração
            var localFwd = {
                x: Math.sin(rad),
                y: 0,
                z: Math.cos(rad)
            };

            var worldFwd = rotateVector(car.transform.rotationq, localFwd);

            if (Math.abs(throttle) > 0.05) {
                var forceMag = throttle * FORCA_MOTOR * dt * 60;
                car.physics.applyForce({
                    x: worldFwd.x * forceMag,
                    y: worldFwd.y * forceMag,
                    z: worldFwd.z * forceMag
                });
            }

            if (Math.abs(steer) > 0.1) {
                car.physics.setAngularVelocity({
                    x: 0, y: steer * VEL_CURVA, z: 0
                });
            }
        }
    </script>
</body>
</html>
