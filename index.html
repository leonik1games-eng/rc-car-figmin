<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SS Play RC - Resgate</title>
    <meta name="figmin">
    <style>
        body {
            background: transparent;
            font-family: sans-serif;
            text-align: center;
            overflow: hidden;
            margin: 0;
            pointer-events: none;
        }
        .hud {
            position: fixed; top: 20px; left: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #3b82f6;
            color: #fff;
            padding: 20px;
            border-radius: 15px;
            text-align: left;
            pointer-events: auto;
            width: 300px;
        }
        .stat { color: #fff; font-weight: bold; font-size: 16px; margin-bottom: 10px;}
        .btn {
            background: #3b82f6; border: none; color: white; padding: 8px 16px;
            border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%;
            margin-top: 10px;
        }
        .btn:active { background: #2563eb; }
        .controls { margin-top: 15px; font-size: 13px; color: #ccc; line-height: 1.6; }
    </style>
</head>
<body>

    <div class="hud">
        <h3 style="margin:0 0 10px 0; color:#3b82f6;">SS PLAY RC <span style="font-size:12px; color:#fff;">v19.0</span></h3>
        
        <div id="status" class="stat">Carregando...</div>
        
        <button class="btn" onclick="tentaConectar()">üîÑ RECONECTAR</button>

        <div class="controls">
            üëâ <b>R2:</b> Acelerar<br>
            üëà <b>L2:</b> R√© / Freio<br>
            üïπÔ∏è <b>Anal√≥gico:</b> Dire√ß√£o
        </div>
    </div>

    <script>
        // --- AJUSTES ---
        const FORCA_MOTOR = 80.0;
        const VEL_CURVA = 3.5;
        const PESO = 3.0;
        const MODELO_DE_LADO = false; // Mude se andar de lado
        // ---------------

        // --- MATEM√ÅTICA DO AVI√ÉO (Para corrigir a dire√ß√£o) ---
        function quaternionMultiply(q1, q2) {
            return {
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
            };
        }
        function quaternionConjugate(q) { return { w: q.w, x: -q.x, y: -q.y, z: -q.z }; }
        function quaternionRotateVector(q, v) {
            var qv = { w: 0, x: v.x, y: v.y, z: v.z };
            var qConj = quaternionConjugate(q);
            var q1 = quaternionMultiply(q, qv);
            var q2 = quaternionMultiply(q1, qConj);
            return { x: q2.x, y: q2.y, z: q2.z };
        }

        // --- SUA CONEX√ÉO ORIGINAL ---
        var car = null;
        var statusDiv = document.getElementById("status");

        // Ocorre automaticamente ao iniciar
        document.addEventListener("FigminReady", tentaConectar);

        // Fun√ß√£o isolada para poder chamar no bot√£o tamb√©m
        function tentaConectar() {
            car = figmin.findObjectByName("meu_carro");
            
            if (car) {
                statusDiv.innerText = "PRONTO! CLIQUE NO RAIO ‚ö°";
                statusDiv.style.color = "#00ff00";
                setupCar();
            } else {
                statusDiv.innerText = "ERRO: 'meu_carro' n√£o achado.";
                statusDiv.style.color = "red";
            }
        }

        function setupCar() {
            // Garante que n√£o duplique a f√≠sica se clicar 2x
            if(car.physics) return; 

            car.addComponent(figmin.ComponentType.PHYSICS, {
                mass: PESO,           
                drag: 2.0,            
                angularDrag: 4.0,     
                gravityStrength: 1.0, 
                kinematic: false      
            });

            figmin.enableInputConnect("Controle RC", [
                figmin.InputCode.SELECT_RIGHT, // R2
                figmin.InputCode.SELECT_LEFT,  // L2
                figmin.InputCode.AXIS_X_RIGHT, // Dire√ß√£o
                figmin.InputCode.BUTTON_1      // Reset
            ], onConnect, car);

            figmin.setUpdateFunction(update);
        }

        function onConnect(connected) {
            statusDiv.innerText = connected ? "PILOTANDO!" : "Desconectado";
            statusDiv.style.color = connected ? "#00ff00" : "yellow";
            if (connected && car.physics) car.physics.wakeUp();
        }

        function update(dt) {
            if (!car || !car.physics) return;

            var throttleFwd = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var throttleRev = figmin.getInput(figmin.InputCode.SELECT_LEFT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var resetBtn = figmin.getInput(figmin.InputCode.BUTTON_1);

            var inputForce = 0;
            if (throttleFwd > 0.05) inputForce = throttleFwd;
            if (throttleRev > 0.05) inputForce = -throttleRev;

            // --- F√çSICA CORRIGIDA (Calcula a frente real) ---
            var thrustLocal = { x: 0, y: 0, z: 0 };
            
            if (MODELO_DE_LADO) {
                thrustLocal.x = inputForce * FORCA_MOTOR;
            } else {
                thrustLocal.z = inputForce * FORCA_MOTOR;
            }

            // Converte for√ßa local para global (Isso resolve o bug da dire√ß√£o!)
            var thrustWorld = quaternionRotateVector(car.transform.rotationq, thrustLocal);

            if (Math.abs(inputForce) > 0.05) {
                car.physics.applyForce({
                    x: thrustWorld.x,
                    y: thrustWorld.y, 
                    z: thrustWorld.z
                });
            }

            // Dire√ß√£o
            if (Math.abs(steer) > 0.1) {
                var currentVel = car.physics.angularVelocity;
                car.physics.setAngularVelocity({
                    x: currentVel.x * 0.5,      
                    y: steer * VEL_CURVA,       
                    z: currentVel.z *
