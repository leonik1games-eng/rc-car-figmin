<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SS Play RC - Arcade</title>
    <meta name="figmin">
    <style>
        /* Visual Limpo */
        body {
            background: transparent;
            font-family: sans-serif;
            text-align: center;
            overflow: hidden;
            margin: 0;
            pointer-events: none; /* Laser atravessa */
        }
        .hud {
            position: fixed;
            top: 20px; left: 20px;
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            max-width: 250px;
            text-align: left;
            pointer-events: auto; /* Permite clique */
        }
        h1 { margin: 0 0 5px; font-size: 16px; color: white; }
        .status { font-weight: bold; color: yellow; margin-top: 5px; }
    </style>
</head>
<body>

    <div class="hud">
        <h1>SS PLAY RC (ARCADE)</h1>
        <div id="status" class="status">Procurando 'meu_carro'...</div>
        <div style="margin-top:10px; font-size:12px; color:#aaa;">
            Use Gatilho R2 p/ Acelerar<br>
            Analógico p/ Virar
        </div>
    </div>

    <script>
        // --- AJUSTES DO LEONI (MEXA AQUI) ---
        
        // Se o carro andar de lado (caranguejo), mude para true
        const CORRIGIR_LADO = false; 

        // Se o carro estiver lento, aumente (Ex: 300, 500)
        const FORCA_MOTOR = 250.0;

        // Se virar pouco, aumente (Ex: 5.0, 8.0)
        const VELOCIDADE_GIRO = 4.0; 

        // ------------------------------------

        var car = null;
        var statusDiv = document.getElementById("status");

        document.addEventListener("FigminReady", init);

        function init() {
            if (!figmin.isSpatialApp()) { figmin.requireSpatialApp(); return; }
            
            // Busca o carro
            car = figmin.findObjectByName("meu_carro");

            if (car) {
                statusDiv.innerText = "CARRO ENCONTRADO! ⚡";
                statusDiv.style.color = "#00ff00";
                setupCar();
            } else {
                statusDiv.innerText = "ERRO: Objeto 'meu_carro' não achado.";
                statusDiv.style.color = "red";
            }
        }

        function setupCar() {
            // FÍSICA "ARCADE" (Leve e Solta)
            car.addComponent(figmin.ComponentType.PHYSICS, {
                mass: 1.0,            // Leve (1kg) para responder rápido
                drag: 0.1,            // Quase zero arrasto (desliza)
                angularDrag: 5.0,     // Para de girar rápido quando solta o analógico
                gravityStrength: 4.0, // Gravidade alta pra colar no chão e não capotar
                collisionDetectionMode: figmin.physics.CollisionDetectionMode.CONTINUOUS_DYNAMIC,
                kinematic: false 
            });

            // PNEU DE GELO (Sem atrito pra não travar)
            car.addComponent(figmin.ComponentType.PHYSICS_MATERIAL, {
                bounciness: 0.0,
                staticFriction: 0.1,
                dynamicFriction: 0.1
            });

            figmin.enableInputConnect("Pilotar", [
                figmin.InputCode.SELECT_RIGHT,
                figmin.InputCode.AXIS_Y_RIGHT,
                figmin.InputCode.AXIS_X_RIGHT,
                figmin.InputCode.THUMB_RIGHT
            ], onConnect, car);

            figmin.setUpdateFunction(update);
        }

        function onConnect(connected) {
            statusDiv.innerText = connected ? "CONECTADO!" : "Desconectado";
            statusDiv.style.color = connected ? "#00ff00" : "yellow";
            if (connected && car.physics) {
                car.physics.kinematic = false;
                car.physics.wakeUp();
            }
        }

        function update(dt) {
            if (!car || !car.physics) return;

            // Inputs
            var throttle = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var stickY = figmin.getInput(figmin.InputCode.AXIS_Y_RIGHT);
            var resetBtn = figmin.getInput(figmin.InputCode.THUMB_RIGHT);

            // Lógica de Ré
            var isReversing = false;
            if (stickY < -0.2) {
                throttle = Math.abs(stickY);
                isReversing = true;
            }

            // --- CORREÇÃO DE DIREÇÃO ---
            var forward = car.transform.forward;
            var right = car.transform.right;
            
            // Se CORRIGIR_LADO for true, usa o vetor Right como frente
            var moveDir = CORRIGIR_LADO ? right : forward;
            var direction = isReversing ? -1 : 1;

            // 1. ACELERAÇÃO (ApplyForce)
            if (throttle > 0.05) {
                // Multiplicador alto (60) para compensar dt
                var forceMag = throttle * FORCA_MOTOR * direction * dt * 60;
                
                car.physics.applyForce({
                    x: moveDir.x * forceMag,
                    y: moveDir.y * forceMag, // Acompanha inclinação
                    z: moveDir.z * forceMag
                });
            }

            // 2. CURVA (SetAngularVelocity) - A MUDANÇA CHAVE
            // Em vez de aplicar força (que briga com o motor), nós DEFINIMOS a rotação.
            if (Math.abs(steer) > 0.1) {
                // Pega a velocidade angular atual pra manter inércia nos outros eixos
                var currentAng = car.physics.angularVelocity;
                
                car.physics.setAngularVelocity({
                    x: currentAng.x,
                    y: steer * VELOCIDADE_GIRO, // Gira na marra!
                    z: currentAng.z
                });
            }

            // 3. ESTABILIZADOR (Anti-Tombo)
            // Se o carro inclinar muito, empurra de volta pro chão
            if (car.transform.up.y < 0.5) {
                car.physics.applyTorque({ 
                    x: forward.x * 5, 
                    y: 0, 
                    z: forward.z * 5 
                });
            }

            // Reset
            if (resetBtn) doReset();
        }

        function doReset() {
            car.physics.setLinearVelocity({x:0, y:0, z:0});
            car.physics.setAngularVelocity({x:0, y:0, z:0});

            var cam = figmin.getCamera();
            var fwd = cam.transform.forward;
            var pos = cam.transform.position;

            car.transform.position = {
                x: pos.x + fwd.x * 1.5,
                y: pos.y - 0.5, 
                z: pos.z + fwd.z * 1.5
            };
            
            if(car.transform.position.y < 0.2) car.transform.position.y = 0.5;
            car.transform.rotation = { x:0, y: cam.transform.rotation.y, z:0 };
        }
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SS Play RC</title>
    <meta name="figmin">
    <style>
        /* VISUAL EXATO DO AVIÃO (AZUL ESCURO) */
        :root {
            --accent: #3b82f6;
            --bg: #020617;
            --text-muted: #9ca3af;
        }

        html, body {
            margin: 0; padding: 0; height: 100%; overflow: hidden;
            background-color: transparent; 
            font-family: system-ui, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .card {
            padding: 24px;
            border-radius: 20px;
            background: rgba(15, 23, 42, 0.95);
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            border: 1px solid rgba(148, 163, 184, 0.35);
            max-width: 400px;
            color: white;
        }

        h1 { margin: 0 0 10px; font-size: 24px; color: white; }
        .info { color: var(--text-muted); font-size: 14px; margin-bottom: 20px; }
        
        .status { 
            font-weight: bold; 
            padding: 10px; 
            border-radius: 8px; 
            background: #333; 
            color: yellow; 
        }
    </style>
</head>
<body>

    <div class="card">
        <h1>SS PLAY RC</h1>
        <div class="info">
            Aponte para o carro e clique no RAIO ⚡.<br>
            Use o Gatilho para acelerar.
        </div>
        <div id="status" class="status">Procurando 'meu_carro'...</div>
    </div>

    <script>
        // --- CONFIGURAÇÃO DE FÍSICA (CARRO) ---
        // Aumentei a força pra garantir que ele ande se for pesado
        const MOTOR = 200.0;
        const CURVA = 30.0;
        const GRAVIDADE = 3.0; // 3x gravidade normal pra colar no chão
        // --------------------------------------

        var car = null;
        var statusDiv = document.getElementById("status");

        // INICIALIZAÇÃO SIMPLES (IGUAL AO AVIÃO)
        document.addEventListener("FigminReady", init);

        function init() {
            // Garante modo AR
            if (!figmin.isSpatialApp()) {
                figmin.requireSpatialApp();
                return;
            }

            // Busca o objeto UMA VEZ.
            car = figmin.findObjectByName("meu_carro");

            if (car) {
                statusDiv.innerText = "CARRO ENCONTRADO! ⚡";
                statusDiv.style.color = "#4ade80"; // Verde
                setupCar();
            } else {
                statusDiv.innerText = "ERRO: Objeto 'meu_carro' não achado.";
                statusDiv.style.color = "red";
            }
        }

        function setupCar() {
            // 1. INJETA A FÍSICA (DYNAMIC)
            // Como você desligou no menu, aqui a gente liga via código.
            car.addComponent(figmin.ComponentType.PHYSICS, {
                mass: 8.0,            // 8kg (Pesado/Estável)
                drag: 2.0,            // Freio aerodinâmico (pra parar quando solta)
                angularDrag: 4.0,     // Pra não rodopiar
                gravityStrength: GRAVIDADE,
                collisionDetectionMode: figmin.physics.CollisionDetectionMode.CONTINUOUS_DYNAMIC,
                kinematic: false 
            });

            // 2. MATERIAL DE PNEU
            car.addComponent(figmin.ComponentType.PHYSICS_MATERIAL, {
                bounciness: 0.0,      // Sem quique
                staticFriction: 0.6,  // Atrito lateral
                dynamicFriction: 0.5
            });

            // 3. ATIVA O RAIO (INPUT CONNECT)
            figmin.enableInputConnect("Pilotar RC", [
                figmin.InputCode.SELECT_RIGHT,
                figmin.InputCode.AXIS_Y_RIGHT,
                figmin.InputCode.AXIS_X_RIGHT,
                figmin.InputCode.THUMB_RIGHT
            ], onConnect, car);

            // 4. LOOP DE CONTROLE
            figmin.setUpdateFunction(update);
        }

        function onConnect(connected) {
            if (connected) {
                statusDiv.innerText = "CONECTADO: PILOTANDO";
                statusDiv.style.background = "#064e3b";
                
                // Acorda a física (Garante que não tá dormindo)
                if(car.physics) {
                    car.physics.kinematic = false;
                    car.physics.wakeUp();
                }
            } else {
                statusDiv.innerText = "DESCONECTADO";
                statusDiv.style.background = "#333";
            }
        }

        function update(dt) {
            if (!car || !car.physics) return;

            // Inputs
            var throttle = figmin.getInput(figmin.InputCode.SELECT_RIGHT);
            var steer = -figmin.getInput(figmin.InputCode.AXIS_X_RIGHT);
            var stickY = figmin.getInput(figmin.InputCode.AXIS_Y_RIGHT);
            var resetBtn = figmin.getInput(figmin.InputCode.THUMB_RIGHT);

            // Ré
            var isReversing = false;
            if (stickY < -0.2) {
                throttle = Math.abs(stickY);
                isReversing = true;
            }

            var forward = car.transform.forward;
            var direction = isReversing ? -1 : 1;

            // Acelerar
            if (throttle > 0.05) {
                var forceX = forward.x * throttle * MOTOR * direction * dt * 60;
                var forceY = forward.y * throttle * MOTOR * direction * dt * 60;
                var forceZ = forward.z * throttle * MOTOR * direction * dt * 60;
                
                car.physics.applyForce({ x: forceX, y: forceY, z: forceZ });
            }

            // Curvar
            if (Math.abs(steer) > 0.1) {
                car.physics.applyTorque({
                    x: 0,
                    y: steer * CURVA * dt * 60,
                    z: 0
                });
            }

            // Estabilização (Anti-Tombo)
            if (car.transform.up.y < 0.5) {
                car.physics.applyTorque({ x: forward.x * 10, y: 0, z: forward.z * 10 });
            }

            // Reset
            if (resetBtn) doReset();
        }

        function doReset() {
            car.physics.setLinearVelocity({x:0, y:0, z:0});
            car.physics.setAngularVelocity({x:0, y:0, z:0});

            var cam = figmin.getCamera();
            var fwd = cam.transform.forward;
            var pos = cam.transform.position;

            // Teleporta
            car.transform.position = {
                x: pos.x + fwd.x * 2.0,
                y: pos.y - 0.5, 
                z: pos.z + fwd.z * 2.0
            };
            
            if(car.transform.position.y < 0.2) car.transform.position.y = 0.5;
            car.transform.rotation = { x:0, y: cam.transform.rotation.y, z:0 };
        }
    </script>
</body>
</html>
